
import * as fs from "fs";

const OUTPUT_DIR = "src/cpplox/ast/";

function writeFile(filename: string, content: string) {
    const path = OUTPUT_DIR + filename;
    fs.writeFileSync(path, content);
}

enum AstEntryType {
    MEMBER,
    UNION
}

interface AstEntryBase {
    name: string
}

interface MemberAstEntry extends AstEntryBase {
    type: AstEntryType.MEMBER;
    members: Record<string, string>
}

interface UnionAstEntry extends AstEntryBase {
    type: AstEntryType.UNION;
    union: string[]
}

type AstEntry = (MemberAstEntry | UnionAstEntry);

type AST = AstEntry[];

const LOX_AST: AST = [
    {
        type: AstEntryType.MEMBER,
        name: "BinaryExpression",
        members: {
            "left": "Expression",
            "op": "Token",
            "right": "Expression"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "GroupingExpression",
        members: {
            "open": "Token",
            "grouped": "Expression",
            "close": "Token"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "UnaryExpression",
        members: {
            "expression": "Expression",
            "unary": "Token"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "LiteralExpression",
        members: {
            "literal": "Token"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "VariableExpression",
        members: {
            "variable": "Token"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "AssignExpression",
        members: {
            "variable": "Token",
            "value": "Expression"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "ExpressionStatement",
        members: {
            "expr": "Expression",
            "semicolon": "Token"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "PrintStatement",
        members: {
            "print": "Token",
            "expr": "Expression",
            "semicolon": "Token"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "VarDeclaration",
        members: {
            "var": "Token",
            "identifier": "Token",
            "equals": "Token",
            "expr": "Expression",
            "semi": "Token"
        }
    },
    {
        type: AstEntryType.MEMBER,
        name: "StatementDeclaration",
        members: {
            "statement": "Statement",
            "identifier": "Token",
            "equals": "Token",
            "expr": "Expression",
            "semi": "Token"
        }
    }
];

function outputMemberType(entry: MemberAstEntry): string {
    let cPlusPlus = ``;
    cPlusPlus += `struct ${entry.name} {\n`
    for (let member in entry.members) {
        cPlusPlus += `\tstruct ${entry.members[member]} *${member};\n`;
    }
    cPlusPlus += "};"
    return cPlusPlus;
}

function outputUnionType(entry: UnionAstEntry): string {
    return ""
}

function outputEntry(entry: AstEntry) {
    switch (entry.type) {
        case AstEntryType.MEMBER:
            return outputMemberType(entry);
        case AstEntryType.UNION:
            return outputUnionType(entry);
    }
}

function outputAst(ast: AST) {
    let source = "// This is generated by scripts/ASTGenerator.ts\n"
    for (let entry of ast) {
        source += outputEntry(entry) + "\n";
    }
    writeFile("ast.h", source);
}


outputAst(LOX_AST);

